!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.awaitility=e():t.awaitility=e()}(self,()=>(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Async:()=>C,DomError:()=>A,DomHandler:()=>I,Handler:()=>g,HandlerError:()=>v,HttpError:()=>S,HttpHandler:()=>k,Path:()=>b,Req:()=>m,Res:()=>p});class r{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return a.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return a.along(this,t=>t.parent)}}class n extends r{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new n).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new n(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class s{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new s;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof s)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new s;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new s;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return s.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return s.equal(this,t)}static along(t,e){const r=new s;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!a.isIterable(t)&&!s.isAsyncIterable(t)||"string"==typeof e||!a.isIterable(e)&&!s.isAsyncIterable(e))return t===e;{const r=s.as(t)[Symbol.asyncIterator](),n=s.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await s.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?s.else(this):s.else([this,s.as(t)])}static else(t){const e=new s;return e[Symbol.asyncIterator]=async function*(){for await(const e of s.as(t)){const t=s.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return s.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},s.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const o=new s;return o[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const o of t)s?yield o:await e(o,r)&&(s=!0,n&&(yield o)),r++}:async function*(){let r=0,s=!1;for await(const o of t){if(s)break;await e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},o}match(t=void 0){return void 0===t?s.match(this):s.match(this,s.as(t))}static match(...t){const e=new s,r=t.map(t=>s.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return s.each(...this);const e=this,r=new s;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of s.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>s.as(t));return i.as(t=>{if(t.length>=e.length)return s.of();const r=e[t.length],n=new s;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return s.self(this)}static self(t){const e=s.as(t),r=new s;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return s.what(this,t,e)}static async what(t,e,r){const n=s.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class o{async what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}async let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),o.as(async(...r)=>await s.equal(t,r)?e:void 0)}static as(t){if(t instanceof o)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,o.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t){return o.retype(o.if(t,this),this)}static if(t,e){return o.as(async(...r)=>await t(...r)?await e(...r):void 0)}sthen(...t){return o.retype(o.sthen(this,...t),this)}static sthen(...t){return o.as(async e=>{let r=e;for(let e of t){if(void 0===r)break;r=await e(r)}return r})}else(t,e=void 0){const r="string"==typeof e?e:void 0,n=e instanceof RegExp?e:void 0;return o.retype(async(...e)=>{let s;try{s=await this(...e)}catch(s){const o=s.message??JSON.stringify(s);if(r&&r===o||n&&n.test(o))return await t(...e,s);throw s}return void 0===s?await t(...e):s},this)}static else(...t){return o.as(async e=>{let r;for(let n of t){try{r=await n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=async t=>void 0!==t){return o.retype(o.which(this,t),this)}static which(t,e=async t=>void 0!==t){return o.as(async(...r)=>{const n=await t(...r);return await e(n,...r)?n:void 0})}when(t){return o.retype(o.when(t,this),this)}static when(t,e){return o.if(t,e)}match(...t){return o.retype(o.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return o.as(e)}each(t){return o.retype(async(...e)=>await s.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return o.as(async e=>{const r=e instanceof n?e:n.of(e);return r.length>t.length?a.of():r.across(await s.as(await o.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(t=void 0,e=void 0){return o.retype(o.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?async e=>e.across(await s.as(await t(e.last)).which().toArray()):async(...e)=>{const n=await t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:"number"==typeof e?async(...n)=>await t(...n.slice(0,e),r,...n.slice(e)):async n=>{let o=[];for await(let t of s.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t))o.push(t);const i=await("string"==typeof t?n[t]:t)(...o);if(void 0!==i)return void 0!==r?(n[r]=i,n):i},o.as(n)}}class i{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),i.as((...r)=>a.equal(t,r)?e:void 0)}static as(t){if(t instanceof i)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,i.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t){return i.retype(i.if(t,this),this)}static if(t,e){return i.as((...r)=>t(...r)?e(...r):void 0)}sthen(t){return i.retype(i.sthen(this,t),this)}static sthen(...t){return i.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=e(r)}return r})}else(t,e=void 0){const r="string"==typeof e?e:void 0,n=e instanceof RegExp?e:void 0;return i.retype((...e)=>{let s;try{s=this(...e)}catch(s){const o=s.message??JSON.stringify(s);if(r&&r===o||n&&n.test(o))return t(...e,s);throw s}return void 0===s?t(...e):s},this)}static else(...t){return i.as(e=>{let r;for(let n of t){try{r=n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return i.retype(i.which(this,t),this)}static which(t,e=t=>void 0!==t){return i.as((...r)=>{const n=t(...r);return e(n,...r)?n:void 0})}when(t){return i.when(t,this)}static when(t,e){return o.as(async(...r)=>await t(...r)?await e(...r):void 0)}match(...t){return i.retype(i.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return i.as(e)}each(t){return i.retype((...e)=>a.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return i.as(e=>{const r=e instanceof n?e:n.of(e);return r.length>t.length?a.of():r.across(a.as(i.as(t[r.length-1])(r.last)).which()).which()})}self(t=void 0,e=void 0){return i.retype(i.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?e=>e.across(a.as(t(e.last)).which()):(...e)=>{const n=t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:"number"==typeof e?(...n)=>t(...n.slice(0,e),r,...n.slice(e)):n=>{const s=a.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t),o=("string"==typeof t?n[t]:t)(...s);if(void 0!==o)return void 0!==r?(n[r]=o,n):o},i.as(n)}}class a{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return a.of();if(t instanceof a)return t;if(t[Symbol.iterator]){const e=new a;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new a;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new a;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return a.equal(this,t)}static equal(t,e){if("string"==typeof t||!a.isIterable(t)||"string"==typeof e||!a.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!a.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return a.if(this,t)}static if(t,e=t=>void 0!==t){return a.which(t,e)}sthen(t){return a.sthen(this,t)}static sthen(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?a.else(this):a.else(a.of(this,a.as(t)))}static else(t){const e=new a;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return a.which(this,t)}static which(t,e=t=>void 0!==t){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return a.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},s.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const o=new a;return o[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let o of t)s?yield o:e(o,r)&&(s=!0,n&&(yield o)),r++}:function*(){let r=0,s=!1;for(let o of t){if(s)break;e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},o}match(t=void 0){return void 0===t?a.match(...this):a.match(this,a.as(t))}static match(...t){const e=new a;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return a.each(...this);const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of a.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),i.as(e=>e.length<t.length?e.across(t[e.length]):a.of())}self(){return a.self(this)}static self(t){const e=new a;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return a.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=a.what(t),t=a.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}a.NATURAL=new a,a.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class c{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return c.of();if(t instanceof c)return t;if(t[Symbol.iterator]){const e=new c;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new c;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new c;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return c.equal(this,t)}static equal(t,e){if("string"==typeof t||!c.isIterable(t)||"string"==typeof e||!c.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!c.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return c.if(this,t)}static if(t,e=t=>void 0!==t){return c.which(t,e)}sthen(t){return c.sthen(this,t)}static sthen(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?c.else(this):c.else(c.of(this,c.as(t)))}static else(t){const e=new c;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return c.which(this,t)}static which(t,e=t=>void 0!==t){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return c.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},w.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new c;return s[Symbol.iterator]=r?function*(){let r=0,s=!1;for(let o of t)s?yield o:e(o,r)&&(s=!0,n&&(yield o)),r++}:function*(){let r=0,s=!1;for(let o of t){if(s)break;e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},s}match(t=void 0){return void 0===t?c.match(...this):c.match(this,c.as(t))}static match(...t){const e=new c;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return c.each(...this);const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of c.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),d.as(e=>e.length<t.length?e.across(t[e.length]):c.of())}self(){return c.self(this)}static self(t){const e=new c;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return c.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=c.what(t),t=c.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}c.NATURAL=new c,c.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class h{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return c.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return c.along(this,t=>t.parent)}}class l extends h{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new l).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new l(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class u{static matches(t,e){if(null==t)return!1;switch(typeof e){case"number":return t.statusCode===e;case"string":return t.constructor?.name===e;case"function":return e(t);case"object":return e instanceof RegExp&&e.test(t.message);default:return!1}}}class f extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class y{async what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}async let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),y.as(async(...r)=>await w.equal(t,r)?e:void 0)}static as(t){if(t instanceof y)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,y.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t){return y.retype(y.if(t,this),this)}static if(t,e){return y.as(async(...r)=>await t(...r)?await e(...r):void 0)}sthen(...t){return y.retype(y.sthen(this,...t),this)}static sthen(...t){return y.as(async e=>{let r=e;for(let e of t){if(void 0===r)break;r=await e(r)}return r})}else(t,e=void 0){return y.retype(async(...r)=>{let n;try{n=await this(...r)}catch(n){if(!e||u.matches(n,e))return t(...r,n);throw n}return void 0===n?await t(...r):n},this)}static else(...t){return y.as(async e=>{let r;for(let n of t){try{r=await n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=async t=>void 0!==t){return y.retype(y.which(this,t),this)}static which(t,e=async t=>void 0!==t){return y.as(async(...r)=>{const n=await t(...r);return await e(n,...r)?n:void 0})}when(t){return y.retype(y.when(t,this),this)}static when(t,e){return y.if(t,e)}match(...t){return y.retype(y.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return y.as(e)}each(t){return y.retype(async(...e)=>await w.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return y.as(async e=>{const r=e instanceof l?e:l.of(e);return r.length>t.length?c.of():r.across(await w.as(await y.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(t=void 0,e=void 0){return y.retype(y.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?async e=>e.across(await w.as(await t(e.last)).which().toArray()):async(...e)=>{const n=await t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:"number"==typeof e?void 0===r?async r=>await y.within(e,()=>t(r),new f(e)):async(...n)=>await t(...n.slice(0,e),r,...n.slice(e)):async n=>{let s=[];for await(let t of w.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t))s.push(t);const o=await("string"==typeof t?n[t]:t)(...s);if(void 0!==o)return void 0!==r?(n[r]=o,n):o},y.as(n)}static async within(t,e,r=new Error(`Operation timed out after ${t}ms`)){let n;try{return await Promise.race([e(),new Promise((e,s)=>{n=setTimeout(()=>s(r),t)})])}finally{clearTimeout(n)}}}class d{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),d.as((...r)=>c.equal(t,r)?e:void 0)}static as(t){if(t instanceof d)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,d.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t){return d.retype(d.if(t,this),this)}static if(t,e){return d.as((...r)=>t(...r)?e(...r):void 0)}sthen(t){return d.retype(d.sthen(this,t),this)}static sthen(...t){return d.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=e(r)}return r})}else(t,e){return d.retype((...r)=>{let n;try{n=this(...r)}catch(n){if(!e||u.matches(n,e))return t(...r,n);throw n}return void 0===n?t(...r):n},this)}static else(...t){return d.as(e=>{let r;for(let n of t){try{r=n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return d.retype(d.which(this,t),this)}static which(t,e=t=>void 0!==t){return d.as((...r)=>{const n=t(...r);return e(n,...r)?n:void 0})}when(t){return d.when(t,this)}static when(t,e){return y.as(async(...r)=>await t(...r)?await e(...r):void 0)}match(...t){return d.retype(d.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return d.as(e)}each(t){return d.retype((...e)=>c.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return d.as(e=>{const r=e instanceof l?e:l.of(e);return r.length>t.length?c.of():r.across(c.as(d.as(t[r.length-1])(r.last)).which()).which()})}self(t=void 0,e=void 0){return d.retype(d.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?e=>e.across(c.as(t(e.last)).which()):(...e)=>{const n=t(...e);if(void 0===n)return;const s={};return s[r]=n,s}:"number"==typeof e?void 0===r?t=>d.within(e,()=>this(t),new TimeoutError(e)):(...n)=>t(...n.slice(0,e),r,...n.slice(e)):n=>{const s=c.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t),o=("string"==typeof t?n[t]:t)(...s);if(void 0!==o)return void 0!==r?(n[r]=o,n):o},d.as(n)}}class w{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new w;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof w)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new w;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new w;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return w.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return w.equal(this,t)}static along(t,e){const r=new w;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!c.isIterable(t)&&!w.isAsyncIterable(t)||"string"==typeof e||!c.isIterable(e)&&!w.isAsyncIterable(e))return t===e;{const r=w.as(t)[Symbol.asyncIterator](),n=w.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await w.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?w.else(this):w.else([this,w.as(t)])}static else(t){const e=new w;return e[Symbol.asyncIterator]=async function*(){for await(const e of w.as(t)){const t=w.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return w.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},w.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new w;return s[Symbol.asyncIterator]=r?async function*(){let r=0,s=!1;for await(const o of t)s?yield o:await e(o,r)&&(s=!0,n&&(yield o)),r++}:async function*(){let r=0,s=!1;for await(const o of t){if(s)break;await e(o,r)?(s=!0,n&&(yield o)):yield o,r++}},s}match(t=void 0){return void 0===t?w.match(this):w.match(this,w.as(t))}static match(...t){const e=new w,r=t.map(t=>w.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return w.each(...this);const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of w.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>w.as(t));return d.as(t=>{if(t.length>=e.length)return w.of();const r=e[t.length],n=new w;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return w.self(this)}static self(t){const e=w.as(t),r=new w;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return w.what(this,t,e)}static async what(t,e,r){const n=w.as(t);if(e){let t=void 0!==r;for await(const s of n)t?r=await e(r,s):(r=s,t=!0);return r}for await(const t of n)return t}}class p{static json(t,e,r,n,s="response"){t.statusCode=e,t.setHeader("Content-Type","application/json"),t.end(JSON.stringify(r)),n?.emit&&n.emit(s,{res:t,code:e,body:r})}static redirect(t,e){t.headersSent||t.writableEnded||(t.statusCode=302,t.setHeader("Location",e),t.end())}static end(t,e,r){return t.statusCode=e,t.end(r)}}class m{static async prepareBody(t,e){if(t.body)return!0;const r=await m.getBody(t);return r&&(t.body=r),!!r}static prepareQuery(t){return t.query||(t.query=m.getQuery(t)),!0}static prepareCookies(t){return t.cookies||(t.cookies=m.getCookies(t)),!0}static prepareToken(t,e={cookie:"token",header:"Authorization",query:"token"}){return t.token||(t.token=this.getToken(t,e)),!!t.token}static async getBody(t){if(t.body)return t.body;if(!["POST","PUT","PATCH"].includes(t.method))return;let e="";if(t.on)for await(const r of t)e+=r;else if("object"==typeof t)return t.body||void 0;const r=(t.headers?.["content-type"]||"").toLowerCase();if(r.includes("application/json"))try{return JSON.parse(e)}catch{throw new Error("Invalid JSON in request body")}if(r.includes("application/x-www-form-urlencoded")){const t=new URLSearchParams(e.trim());return Object.fromEntries(t.entries())}return e}static getCookies(t){if(t.cookies)return t.cookies;const e=t?.headers?.cookie;return e?Object.fromEntries(e.split(";").map(t=>t.split("=").map(t=>t.trim())).filter(([t,e])=>t&&e).map(([t,e])=>[t,decodeURIComponent(e)])):{}}static getQuery(t){if(t.query)return t.query;try{const e=new URL(t?.url||"","http://localhost");return Object.fromEntries(e.searchParams.entries())}catch{return{}}}static getToken(t,e={cookie:"token",header:"Authorization",query:"token"}){const r=m.getCookies(t);if(r&&r[e.cookie])return r[e.cookie];const n=t?.headers?.[e.header?.toLowerCase()];if(n){const t=n.split(" ");return 2===t.length&&/^Bearer$/i.test(t[0])?t[1]:n}const s=m.getQuery(t);return s&&s[e.query]?s[e.query]:void 0}static enforceMethod(t,e,r){const n=Array.isArray(t)?t.map(t=>t.toUpperCase()):t.split(/(?:,|\s)+/).map(t=>t.trim().toUpperCase()).filter(Boolean),s=e.method.toUpperCase();return!!n.includes(s)||(r.setHeader("Allow",n.join(", ")),p.json(r,405,{success:!1,error:"Method Not Allowed"}),!1)}}class b{static normalize(t){if("string"!=typeof t||!t.trim())return"/";try{let e=decodeURIComponent(t).replace(/\/{2,}/g,"/");return e.startsWith("/")||(e="/"+e),e.length>1&&e.endsWith("/")&&(e=e.slice(0,-1)),e||"/"}catch{return"/"}}static isBase(t,e){return"/"===t||t===e||e.startsWith(t+"/")}static*subpaths(t){if("/"===(t=t.trim()))return void(yield t);const e=t.startsWith("/")?"/":"",r=t.split("/");let n;for(let t of r)n=n?n+"/"+t:t,yield e+n}static route(t,e,r,n){const s=e.toUpperCase();if(t&&"function"==typeof t[s.toLowerCase()])t[s.toLowerCase()](r,async(t,e,r)=>{try{await n(t,e)}catch(t){r(t)}});else if(t&&"function"==typeof t.route)t.route({method:s,url:r,handler:n});else if(t&&"function"==typeof t.use&&Array.isArray(t.middleware))t.use(async(t,e)=>{if(t.method.toUpperCase()===s&&t.path===r)try{await n(t.req,t.res),t.respond=!1}catch(e){t.status=500,t.body={error:e.message}}else await e()});else{if(!t||"function"!=typeof t.on)throw new Error("Unsupported application framework");t.on("request",async(t,e)=>{const o=new URL(t.url,`http://${t.headers.host}`).pathname;if(t.method.toUpperCase()===s&&o===r)try{await m.prepare(t,e),await n(t,e)}catch(t){e.statusCode=500,e.end(t.message)}})}}static get(t,e){e=b.keys(e);let r=t;for(const t of e){if(null==r||!(t in r))return;r=r[t]}return r}static set(t,e,r,n=!1){if(!(e=b.keys(e)).length)throw new Error("Invalid path: empty keys");let s=t,o=0;for(const t of e.slice(0,-1)){if(!(t in s)){if(!n)throw new Error(`nonexistent path: ${e.slice(0,o+1).join(".")}`);s[t]={}}s=s[t],o++}s[e[e.length-1]]=r}static delete(t,e){e=b.keys(e),delete b.get(t,e.slice(0,-1))[e[e.length-1]]}static keys(t){return"string"==typeof t?t.split(".").filter(Boolean):[...t]}static isAncestor(t,e){const r=b.keys(t),n=b.keys(e);if(r.length>n.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==n[t])return!1;return!0}}class v extends Error{constructor(t,e,r){super(t),this.name=this.constructor.name,this.path=e,r&&(this.cause=r)}static build(t,e,r,n){let s="function"==typeof e?e(t,r,n):e;return n&&!s.cause&&(s.cause=n),s}}class g extends o{static metaCtx="_hMeta";static as(t=t=>t,e=g.prototype){const r=o.as(t);return Object.setPrototypeOf(r,e),r}checking(t,e=async t=>!!t,r){return this.if(async n=>{if(!await e(g.ctx(n,t)))throw v.build(t,r,n);return n})}check(t,e=async t=>!!t,r){return this.sthen(async n=>{if(!await e(g.ctx(n,t)))throw v.build(t,r,n);return n})}setting(t,e,r=!0,n){return this.if(s=>g.doSet(s,t,e,r,n))}set(t,e,r=!0,n){return this.sthen(s=>g.doSet(s,t,e,r,n))}static async doSet(t,e,r,n=!0,s){try{const s=g.currentCtx(t),o="function"==typeof r?await r(s):await r;if(void 0===o)throw new Error("undefined result");return b.set(s,e,o,n),t}catch(r){throw v.build(e,s,t,r)}}with(t,e=!0,r){return this.sthen(async n=>{let s=await b.get(n,g.metaCtx);s||(s=[],b.set(n,g.metaCtx,s));const o=s[s.length-1]||n;let i=b.get(o,t);if(void 0===i){if(!e)throw v.build(t,r,n);i={},b.set(o,t,i,!0)}return s.push(i),n})}without(t=1){return this.sthen(async e=>{let r=await b.get(e,g.metaCtx);if(Array.isArray(r)&&r.length>0){const n=Math.min(r.length,t);r.splice(r.length-n,n),r.length||b.delete(e,g.metaCtx)}return e})}static currentCtx(t){const e=b.get(t,g.metaCtx);return e?.at(-1)??t}static ctx(t,e){const r=g.currentCtx(t);return b.get(r,e)}}class S extends v{constructor(t,e,r,n){super(e,r,n),this.statusCode=t}}class k extends g{static as(t=t=>t){const e=g.as(t);return Object.setPrototypeOf(e,k.prototype),e}preparingBody(t=new S(422,"invalid or malformed JSON body")){return this.checking("req",async t=>await m.prepareBody(t),t)}prepareBody(t=new S(422,"invalid or malformed JSON body")){return this.check("req",async t=>await m.prepareBody(t),t)}preparingQuery(){return this.checking("req",t=>m.prepareQuery(t))}prepareQuery(){return this.check("req",t=>m.prepareQuery(t))}preparingCookies(){return this.checking("req",t=>m.prepareCookies(t))}prepareCookies(){return this.check("req",t=>m.prepareCookies(t))}preparingToken(t=new S(401,"missing authentication token")){return this.checking("req",t=>m.prepareToken(t),t)}prepareToken(t=new S(401,"missing authentication token")){return this.check("req",t=>m.prepareToken(t),t)}}class A extends v{constructor(t,e,r=!1,n){super(t,e,n),this.isQuery=r}}class I extends g{static as(t=t=>t){const e=g.as(t);return Object.setPrototypeOf(e,I.prototype),e}with(t,e=!1,r=new A("Node not found for selector",t,e)){if(e){const e=this.sthen(e=>{const n=I.currentCtx(e,this.metaCtx);if(!(n instanceof Element||n instanceof Document))throw HandlerError.build(t,r,e,new A("DomHandler.with: current context is not a DOM node, cannot querySelector",t,!0));const s=n.querySelector(t);if(!s)throw HandlerError.build(t,r,e,new A("DomHandler.with: querySelector failed",t,!0));const o=e[this.metaCtx]||[];return o.push(s),e[this.metaCtx]=o,e});return e.metaCtx=this.metaCtx,e}return super.with(t,!0)}settingAttr(t,e,r){return this.setting(`attributes.${t}.value`,e,!0,r||new A(`Attribute not set: ${t}`,t,!0))}checkingAttr(t,e=t=>!!t,r){return this.checking(`attributes.${t}.value`,e,r||new A(`Invalid or missing attribute: ${t}`,t,!0))}setAttr(t,e,r){return this.set(`attributes.${t}.value`,e,!0,r||new A(`Attribute not set: ${t}`,t,!0))}checkAttr(t,e=t=>!!t,r){return this.check(`attributes.${t}.value`,e,r||new A(`Invalid or missing attribute: ${t}`,t,!0))}}class C{static on(t,e,r,n,s,o){if(o||(o=t),"string"==typeof o&&(o=t[o]||(t[o]={})),s&&o[s]&&this.off(t,e,s,n,o),n?.once&&"function"==typeof t.once)t.once(e,r);else if("function"==typeof t.addEventListener)t.addEventListener(e,r,n);else if("function"==typeof t.addListener)t.addListener(e,r);else{if("function"!=typeof t.on)throw new Error("on-failed",{event:e,fn:r,opts:n,name:s,registry:o},t);t.on(e,r)}s&&(o[s]=r)}static off(t,e,r,n,s){let o=r;if("string"==typeof r){if("string"==typeof s&&(s=t[s]),!s)return;o=s[r],delete s[r]}if(o)if("function"==typeof t.removeEventListener)t.removeEventListener(e,o,n);else if("function"==typeof t.removeListener)t.removeListener(e,o);else{if("function"!=typeof t.off)throw new Notification("off-failed",{event:e,nameOrFn:r,opts:n,registry:s},t);t.off(e,o)}}static emit(t,e,...r){if("string"!=typeof e&&(r=[e],e=e?.type||"object"),"function"==typeof t.emit)return t.emit(e,...r);if("function"==typeof t.dispatchEvent)return t.dispatchEvent(C.toCustomEvent(r[0]));throw new Error("emit-failed: Target cannot emit events")}static toCustomEvent(t,e="object"){return t instanceof CustomEvent?t:"string"==typeof t?new CustomEvent(t,{detail:{}}):new CustomEvent(t?.type||e,{obj:t})}}return e})());