!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.awaitility=e():t.awaitility=e()}(self,()=>(()=>{"use strict";var t={d:(e,r)=>{for(var n in r)t.o(r,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:r[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Async:()=>C,DomError:()=>A,DomHandler:()=>I,Handler:()=>v,HandlerError:()=>g,HttpError:()=>S,HttpHandler:()=>k,Path:()=>b,Req:()=>m,Res:()=>p});class r{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return a.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return a.along(this,t=>t.parent)}}class n extends r{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new n).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new n(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class o{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new o;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof o)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new o;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new o;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return o.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return o.equal(this,t)}static along(t,e){const r=new o;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!a.isIterable(t)&&!o.isAsyncIterable(t)||"string"==typeof e||!a.isIterable(e)&&!o.isAsyncIterable(e))return t===e;{const r=o.as(t)[Symbol.asyncIterator](),n=o.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await o.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?o.else(this):o.else([this,o.as(t)])}static else(t){const e=new o;return e[Symbol.asyncIterator]=async function*(){for await(const e of o.as(t)){const t=o.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return o.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},o.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new o;return s[Symbol.asyncIterator]=r?async function*(){let r=0,o=!1;for await(const s of t)o?yield s:await e(s,r)&&(o=!0,n&&(yield s)),r++}:async function*(){let r=0,o=!1;for await(const s of t){if(o)break;await e(s,r)?(o=!0,n&&(yield s)):yield s,r++}},s}match(t=void 0){return void 0===t?o.match(this):o.match(this,o.as(t))}static match(...t){const e=new o,r=t.map(t=>o.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return o.each(...this);const e=this,r=new o;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of o.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>o.as(t));return i.as(t=>{if(t.length>=e.length)return o.of();const r=e[t.length],n=new o;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return o.self(this)}static self(t){const e=o.as(t),r=new o;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return o.what(this,t,e)}static async what(t,e,r){const n=o.as(t);if(e){let t=void 0!==r;for await(const o of n)t?r=await e(r,o):(r=o,t=!0);return r}for await(const t of n)return t}}class s{async what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}async let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),s.as(async(...r)=>await o.equal(t,r)?e:void 0)}static as(t){if(t instanceof s)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,s.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t){return s.retype(s.if(t,this),this)}static if(t,e){return s.as(async(...r)=>await t(...r)?await e(...r):void 0)}sthen(...t){return s.retype(s.sthen(this,...t),this)}static sthen(...t){return s.as(async e=>{let r=e;for(let e of t){if(void 0===r)break;r=await e(r)}return r})}else(t,e=void 0){const r="string"==typeof e?e:void 0,n=e instanceof RegExp?e:void 0;return s.retype(async(...e)=>{let o;try{o=await this(...e)}catch(o){const s=o.message??JSON.stringify(o);if(r&&r===s||n&&n.test(s))return await t(...e,o);throw o}return void 0===o?await t(...e):o},this)}static else(...t){return s.as(async e=>{let r;for(let n of t){try{r=await n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=async t=>void 0!==t){return s.retype(s.which(this,t),this)}static which(t,e=async t=>void 0!==t){return s.as(async(...r)=>{const n=await t(...r);return await e(n,...r)?n:void 0})}when(t){return s.retype(s.when(t,this),this)}static when(t,e){return s.if(t,e)}match(...t){return s.retype(s.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return s.as(e)}each(t){return s.retype(async(...e)=>await o.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return s.as(async e=>{const r=e instanceof n?e:n.of(e);return r.length>t.length?a.of():r.across(await o.as(await s.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(t=void 0,e=void 0){return s.retype(s.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?async e=>e.across(await o.as(await t(e.last)).which().toArray()):async(...e)=>{const n=await t(...e);if(void 0===n)return;const o={};return o[r]=n,o}:"number"==typeof e?async(...n)=>await t(...n.slice(0,e),r,...n.slice(e)):async n=>{let s=[];for await(let t of o.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t))s.push(t);const i=await("string"==typeof t?n[t]:t)(...s);if(void 0!==i)return void 0!==r?(n[r]=i,n):i},s.as(n)}}class i{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),i.as((...r)=>a.equal(t,r)?e:void 0)}static as(t){if(t instanceof i)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,i.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t){return i.retype(i.if(t,this),this)}static if(t,e){return i.as((...r)=>t(...r)?e(...r):void 0)}sthen(t){return i.retype(i.sthen(this,t),this)}static sthen(...t){return i.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=e(r)}return r})}else(t,e=void 0){const r="string"==typeof e?e:void 0,n=e instanceof RegExp?e:void 0;return i.retype((...e)=>{let o;try{o=this(...e)}catch(o){const s=o.message??JSON.stringify(o);if(r&&r===s||n&&n.test(s))return t(...e,o);throw o}return void 0===o?t(...e):o},this)}static else(...t){return i.as(e=>{let r;for(let n of t){try{r=n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return i.retype(i.which(this,t),this)}static which(t,e=t=>void 0!==t){return i.as((...r)=>{const n=t(...r);return e(n,...r)?n:void 0})}when(t){return i.when(t,this)}static when(t,e){return s.as(async(...r)=>await t(...r)?await e(...r):void 0)}match(...t){return i.retype(i.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return i.as(e)}each(t){return i.retype((...e)=>a.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return i.as(e=>{const r=e instanceof n?e:n.of(e);return r.length>t.length?a.of():r.across(a.as(i.as(t[r.length-1])(r.last)).which()).which()})}self(t=void 0,e=void 0){return i.retype(i.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?e=>e.across(a.as(t(e.last)).which()):(...e)=>{const n=t(...e);if(void 0===n)return;const o={};return o[r]=n,o}:"number"==typeof e?(...n)=>t(...n.slice(0,e),r,...n.slice(e)):n=>{const o=a.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t),s=("string"==typeof t?n[t]:t)(...o);if(void 0!==s)return void 0!==r?(n[r]=s,n):s},i.as(n)}}class a{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return a.of();if(t instanceof a)return t;if(t[Symbol.iterator]){const e=new a;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new a;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new a;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return a.equal(this,t)}static equal(t,e){if("string"==typeof t||!a.isIterable(t)||"string"==typeof e||!a.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!a.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return a.if(this,t)}static if(t,e=t=>void 0!==t){return a.which(t,e)}sthen(t){return a.sthen(this,t)}static sthen(t,e){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?a.else(this):a.else(a.of(this,a.as(t)))}static else(t){const e=new a;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return a.which(this,t)}static which(t,e=t=>void 0!==t){const r=new a;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return a.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},o.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const s=new a;return s[Symbol.iterator]=r?function*(){let r=0,o=!1;for(let s of t)o?yield s:e(s,r)&&(o=!0,n&&(yield s)),r++}:function*(){let r=0,o=!1;for(let s of t){if(o)break;e(s,r)?(o=!0,n&&(yield s)):yield s,r++}},s}match(t=void 0){return void 0===t?a.match(...this):a.match(this,a.as(t))}static match(...t){const e=new a;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return a.each(...this);const e=this,r=new a;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of a.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),i.as(e=>e.length<t.length?e.across(t[e.length]):a.of())}self(){return a.self(this)}static self(t){const e=new a;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return a.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=a.what(t),t=a.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}a.NATURAL=new a,a.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class c{[Symbol.iterator](){throw"abstract method!"}static as(t){if(void 0===t)return c.of();if(t instanceof c)return t;if(t[Symbol.iterator]){const e=new c;return e[Symbol.iterator]=t[Symbol.iterator].bind(t),e}{const e=new c;return e[Symbol.iterator]=function*(){yield t},e}}static of(...t){const e=new c;return e[Symbol.iterator]=function*(){for(const e of t)yield e},e}static along(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=t;for(;r;)yield r,r=e(r)},r}toArray(){return Array.from(this)}equals(t){return c.equal(this,t)}static equal(t,e){if("string"==typeof t||!c.isIterable(t)||"string"==typeof e||!c.isIterable(e))return t===e;{const r=t[Symbol.iterator](),n=e[Symbol.iterator]();for(;;){const t=r.next(),e=n.next();if(t.done||e.done)return t.done===e.done;if(!c.equal(t.value,e.value))return!1}}}static isIterable(t){return null!=t&&"function"==typeof t[Symbol.iterator]}if(t=t=>void 0!==t){return c.if(this,t)}static if(t,e=t=>void 0!==t){return c.which(t,e)}sthen(t){return c.sthen(this,t)}static sthen(t,e){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)yield e(n,r++)},r}else(t=void 0){return void 0===t?c.else(this):c.else(c.of(this,c.as(t)))}static else(t){const e=new c;return e[Symbol.iterator]=function*(){for(let e of t)if(e[Symbol.iterator])for(let t of e)yield t;else yield e},e}which(t=t=>void 0!==t){return c.which(this,t)}static which(t,e=t=>void 0!==t){const r=new c;return r[Symbol.iterator]=function*(){let r=0;for(let n of t)e(n,r++)&&(yield n)},r}when(t,e=!0,r=e){return c.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},w.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const o=new c;return o[Symbol.iterator]=r?function*(){let r=0,o=!1;for(let s of t)o?yield s:e(s,r)&&(o=!0,n&&(yield s)),r++}:function*(){let r=0,o=!1;for(let s of t){if(o)break;e(s,r)?(o=!0,n&&(yield s)):yield s,r++}},o}match(t=void 0){return void 0===t?c.match(...this):c.match(this,c.as(t))}static match(...t){const e=new c;return e[Symbol.iterator]=function*(){const e=t.map(t=>t[Symbol.iterator]());for(;;){const t=e.map(t=>t.next());if(t.some(t=>t.done))break;yield t.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return c.each(...this);const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of e)for(let e of c.as(t))yield[r,e]},r}static each(...t){return t=t.map(t=>t[Symbol.iterator]?t:[t]),d.as(e=>e.length<t.length?e.across(t[e.length]):c.of())}self(){return c.self(this)}static self(t){const e=new c;return e[Symbol.iterator]=function*(){for(;;)yield t},e}what(t=void 0,e=void 0){return c.what(this,t,e)}static what(t,e,r){if(e){void 0===r&&(r=c.what(t),t=c.when(t,1));for(let n of t)r=e(r,n);return r}for(let e of t)return e}}c.NATURAL=new c,c.NATURAL[Symbol.iterator]=function*(){let t=0;for(;;)yield t++};class h{constructor(t=void 0,e=void 0,r={}){this._parent=t,this._name=e,this._children=r}get parent(){return this._parent}set parent(t){this._parent=t}get name(){return this._name}let(t,e){return this[t]=e,this}letChild(t,e){return this._children[t]=e,e.parent=this,e._name=t,this}get(...t){return this.ancestors().which(e=>t.every(t=>void 0!==e[t])).then(e=>e[t[0]]).what()}getChild(...t){let e=this;for(const r of t)if(e=e?._children?.[r],!e)break;return e}resolve(t){return"string"==typeof t?this.get(t):t}forget(t){return delete this[t],this}isLeaf(){return void 0===this.children().what()}isRoot(){return void 0===this.parent}children(){return c.as(Object.values(this._children))}root(){return this.parent?this.parent.root():this}ancestors(){return c.along(this,t=>t.parent)}}class l extends h{constructor(t=void 0,e=void 0){super(t,void 0),this._last=e,this._length=t?t._length+1:void 0!==e?1:0}static of(...t){return(new l).along(t)}get prev(){return this._parent}get last(){return this._last}get length(){return this._length}let(t,e){throw new Error("A Path is immutable!")}letChild(t,e){throw new Error("A Path is immutable!")}forget(t){throw new Error("A Path is immutable!")}isEmpty(){return 0==this._length}add(t){return new l(0<this.length?this:void 0,t)}along(t){let e=this;for(let r of t)e=e.add(r);return e}across(t){const e=this,r=new c;return r[Symbol.iterator]=function*(){for(let r of t)yield e.add(r)},r}toArray(t=this.length,e=t=>t){const r=new Array(t);let n=this;for(;0<t;)r[t-1]=e(n.last),n=n.prev,t--;return r}}class u{static matches(t,e){if(null==t)return!1;switch(typeof e){case"number":return t.statusCode===e;case"string":return t.constructor?.name===e;case"function":return e(t);case"object":return e instanceof RegExp&&e.test(t.message);default:return!1}}}class f extends Error{constructor(t,e="Operation timed out",r){super(e),this.millis=t,this.name=this.constructor.name,r&&(this.cause=r)}}class y{async what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}async let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),y.as(async(...r)=>await w.equal(t,r)?e:void 0)}static as(t){if(t instanceof y)return t;if("function"!=typeof t){const e=t;t=async()=>e}const e=async(...e)=>await t(...e);return Object.setPrototypeOf(e,y.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=async t=>void 0!==t){return y.retype(y.if(t,this),this)}static if(t,e){return y.as(async(...r)=>await t(...r)?await e(...r):void 0)}sthen(...t){return y.retype(y.sthen(this,...t),this)}static sthen(...t){return y.as(async e=>{let r=e;for(let e of t){if(void 0===r)break;r=await e(r)}return r})}else(t,e=void 0){return y.retype(async(...r)=>{let n;try{n=await this(...r)}catch(n){if(!e||u.matches(n,e))return t(...r,n);throw n}return void 0===n?await t(...r):n},this)}static else(...t){return y.as(async e=>{let r;for(let n of t){try{r=await n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=async t=>void 0!==t){return y.retype(y.which(this,t),this)}static which(t,e=async t=>void 0!==t){return y.as(async(...r)=>{const n=await t(...r);return await e(n,...r)?n:void 0})}when(t){return y.retype(y.when(t,this),this)}static when(t,e){return y.if(t,e)}match(...t){return y.retype(y.match(this,...t),this)}static match(...t){const e=t.length<2?async e=>[e,await t[0](e)]:async e=>{const r=[];for(let n of t)r.push(await n(e));return r};return y.as(e)}each(t){return y.retype(async(...e)=>await w.as(await this(...e)).which().sthen(t).which().else().toArray(),this)}static each(...t){return y.as(async e=>{const r=e instanceof l?e:l.of(e);return r.length>t.length?c.of():r.across(await w.as(await y.as(t[r.length-1])(r.last)).which().toArray()).which()})}self(t=void 0,e=void 0){return y.retype(y.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?async e=>e.across(await w.as(await t(e.last)).which().toArray()):async(...e)=>{const n=await t(...e);if(void 0===n)return;const o={};return o[r]=n,o}:"number"==typeof e?void 0===r?async r=>await y.within(e,()=>t(r),new f(e)):async(...n)=>await t(...n.slice(0,e),r,...n.slice(e)):async n=>{let o=[];for await(let t of w.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t))o.push(t);const s=await("string"==typeof t?n[t]:t)(...o);if(void 0!==s)return void 0!==r?(n[r]=s,n):s},y.as(n)}static async within(t,e,r=new Error(`Operation timed out after ${t}ms`)){let n;try{return await Promise.race([e(),new Promise((e,o)=>{n=setTimeout(()=>o(r),t)})])}finally{clearTimeout(n)}}}class d{what(...t){throw new Error("Abstract method what() must be implemented in subclasses!")}let(t,e){throw new Error("Abstract method let() must be implemented!")}static of(t,e){return Array.isArray(t)||(t=[t]),d.as((...r)=>c.equal(t,r)?e:void 0)}static as(t){if(t instanceof d)return t;if("function"!=typeof t){const e=t;t=()=>e}const e=(...e)=>t(...e);return Object.setPrototypeOf(e,d.prototype),e.what=t,e}static retype(t,e){return Object.setPrototypeOf(t,Object.getPrototypeOf(e)),t}if(t=t=>void 0!==t){return d.retype(d.if(t,this),this)}static if(t,e){return d.as((...r)=>t(...r)?e(...r):void 0)}sthen(t){return d.retype(d.sthen(this,t),this)}static sthen(...t){return d.as(e=>{let r=e;for(let e of t){if(void 0===r)break;r=e(r)}return r})}else(t,e){return d.retype((...r)=>{let n;try{n=this(...r)}catch(n){if(!e||u.matches(n,e))return t(...r,n);throw n}return void 0===n?t(...r):n},this)}static else(...t){return d.as(e=>{let r;for(let n of t){try{r=n(e)}catch{r=void 0}if(void 0!==r)break}return r})}which(t=t=>void 0!==t){return d.retype(d.which(this,t),this)}static which(t,e=t=>void 0!==t){return d.as((...r)=>{const n=t(...r);return e(n,...r)?n:void 0})}when(t){return d.when(t,this)}static when(t,e){return y.as(async(...r)=>await t(...r)?await e(...r):void 0)}match(...t){return d.retype(d.match(this,...t),this)}static match(...t){const e=t.length<2?e=>[e,t[0](e)]:e=>t.map(t=>t(e));return d.as(e)}each(t){return d.retype((...e)=>c.as(this(...e)).which().sthen(t).which().else(),this)}static each(...t){return d.as(e=>{const r=e instanceof l?e:l.of(e);return r.length>t.length?c.of():r.across(c.as(d.as(t[r.length-1])(r.last)).which()).which()})}self(t=void 0,e=void 0){return d.retype(d.self(this,t,e),this)}static self(t,e=void 0,r=void 0){let n;return n=void 0===e?void 0===r?e=>e.across(c.as(t(e.last)).which()):(...e)=>{const n=t(...e);if(void 0===n)return;const o={};return o[r]=n,o}:"number"==typeof e?void 0===r?t=>d.within(e,()=>this(t),new TimeoutError(e)):(...n)=>t(...n.slice(0,e),r,...n.slice(e)):n=>{const o=c.as("string"==typeof e?[e]:e).sthen(t=>"string"==typeof t?n[t]:t),s=("string"==typeof t?n[t]:t)(...o);if(void 0!==s)return void 0!==r?(n[r]=s,n):s},d.as(n)}}class w{[Symbol.asyncIterator](){throw"abstract method!"}static of(...t){const e=new w;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield await e},e}static as(t){if(t instanceof w)return t;if(null!=t&&"function"==typeof t[Symbol.asyncIterator]){const e=new w;return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},e}if(null!=t&&"function"==typeof t[Symbol.iterator]){const e=new w;return e[Symbol.asyncIterator]=async function*(){for(const e of t)yield e},e}return w.of(t)}async toArray(){const t=[];for await(const e of this)t.push(e);return t}async equals(t){return w.equal(this,t)}static along(t,e){const r=new w;return r[Symbol.asyncIterator]=async function*(){let r=t;for(;null!=r;)yield r,r=await e(r)},r}static async equal(t,e){if("string"==typeof t||!c.isIterable(t)&&!w.isAsyncIterable(t)||"string"==typeof e||!c.isIterable(e)&&!w.isAsyncIterable(e))return t===e;{const r=w.as(t)[Symbol.asyncIterator](),n=w.as(e)[Symbol.asyncIterator]();for(;;){const t=await r.next(),e=await n.next();if(t.done||e.done)return t.done===e.done;if(!await w.equal(t.value,e.value))return!1}}}static isAsyncIterable(t){return null!=t&&"function"==typeof t[Symbol.asyncIterator]}if(t=t=>void 0!==t){const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)await t(n,r++)&&(yield n)},r}sthen(t){const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){let r=0;for await(const n of e)yield await t(n,r++)},r}else(t=void 0){return void 0===t?w.else(this):w.else([this,w.as(t)])}static else(t){const e=new w;return e[Symbol.asyncIterator]=async function*(){for await(const e of w.as(t)){const t=w.as(e);for await(const e of t)yield e}},e}which(t){return this.if(t)}when(t,e=!0,r=e){return w.when(this,t,e,r)}static when(t,e,r=!0,n=r){if(void 0===e){const e={};return e[Symbol.asyncIterator]=async function*(){for await(const e of t)yield e},w.as(e)}if("number"==typeof e){const t=e;e=(e,r)=>r===t}const o=new w;return o[Symbol.asyncIterator]=r?async function*(){let r=0,o=!1;for await(const s of t)o?yield s:await e(s,r)&&(o=!0,n&&(yield s)),r++}:async function*(){let r=0,o=!1;for await(const s of t){if(o)break;await e(s,r)?(o=!0,n&&(yield s)):yield s,r++}},o}match(t=void 0){return void 0===t?w.match(this):w.match(this,w.as(t))}static match(...t){const e=new w,r=t.map(t=>w.as(t));return e[Symbol.asyncIterator]=async function*(){const t=r.map(t=>t[Symbol.asyncIterator]());for(;;){const e=await Promise.all(t.map(t=>t.next()));if(e.some(t=>t.done))break;yield e.map(t=>t.value)}},e}each(t=void 0){if(void 0===t)return w.each(...this);const e=this,r=new w;return r[Symbol.asyncIterator]=async function*(){for await(const r of e)for await(const e of w.as(t))yield[r,e]},r}static each(...t){const e=t.map(t=>w.as(t));return d.as(t=>{if(t.length>=e.length)return w.of();const r=e[t.length],n=new w;return n[Symbol.asyncIterator]=async function*(){for await(const e of r)yield t.add(e)},n})}self(){return w.self(this)}static self(t){const e=w.as(t),r=new w;return r[Symbol.asyncIterator]=async function*(){for(;;)yield e},r}async what(t,e){return w.what(this,t,e)}static async what(t,e,r){const n=w.as(t);if(e){let t=void 0!==r;for await(const o of n)t?r=await e(r,o):(r=o,t=!0);return r}for await(const t of n)return t}}class p{static json(t,e,r,n,o="response"){t.statusCode=e,t.setHeader("Content-Type","application/json"),t.end(JSON.stringify(r)),n?.emit&&n.emit(o,{res:t,code:e,body:r})}static redirect(t,e){t.headersSent||t.writableEnded||(t.statusCode=302,t.setHeader("Location",e),t.end())}static end(t,e,r){return t.statusCode=e,t.end(r)}}class m{static async prepareBody(t,e){if(t.body)return!0;const r=await m.getBody(t);return r&&(t.body=r),!!r}static prepareQuery(t){return t.query||(t.query=m.getQuery(t)),!0}static prepareCookies(t){return t.cookies||(t.cookies=m.getCookies(t)),!0}static prepareToken(t,e={cookie:"token",header:"Authorization",query:"token"}){return t.token||(t.token=this.getToken(t,e)),!!t.token}static prepareURL(t){return t.URL||(t.URL=this.getURL(t)),!!t.URL}static getURL(t){const e=`http://${t.headers.host||"localhost"}`,r=new URL(t.url,e);return r.pathname=b.normalize(r.pathname),r}static async getBody(t){if(t.body)return t.body;if(!["POST","PUT","PATCH"].includes(t.method))return;let e="";if(t.on)for await(const r of t)e+=r;else if("object"==typeof t)return t.body||void 0;const r=(t.headers?.["content-type"]||"").toLowerCase();if(r.includes("application/json"))try{return JSON.parse(e)}catch{throw new Error("Invalid JSON in request body")}if(r.includes("application/x-www-form-urlencoded")){const t=new URLSearchParams(e.trim());return Object.fromEntries(t.entries())}return e}static getCookies(t){if(t.cookies)return t.cookies;const e=t?.headers?.cookie;return e?Object.fromEntries(e.split(";").map(t=>t.split("=").map(t=>t.trim())).filter(([t,e])=>t&&e).map(([t,e])=>[t,decodeURIComponent(e)])):{}}static getQuery(t){if(t.query)return t.query;try{const e=new URL(t?.url||"","http://localhost");return Object.fromEntries(e.searchParams.entries())}catch{return{}}}static getToken(t,e={cookie:"token",header:"Authorization",query:"token"}){const r=m.getCookies(t);if(r&&r[e.cookie])return r[e.cookie];const n=t?.headers?.[e.header?.toLowerCase()];if(n){const t=n.split(" ");return 2===t.length&&/^Bearer$/i.test(t[0])?t[1]:n}const o=m.getQuery(t);return o&&o[e.query]?o[e.query]:void 0}static enforceMethod(t,e,r){const n=Array.isArray(t)?t.map(t=>t.toUpperCase()):t.split(/(?:,|\s)+/).map(t=>t.trim().toUpperCase()).filter(Boolean),o=e.method.toUpperCase();return!!n.includes(o)||(r.setHeader("Allow",n.join(", ")),p.json(r,405,{success:!1,error:"Method Not Allowed"}),!1)}}class b{static normalize(t){if("string"!=typeof t||!t.trim())return"/";try{let e=decodeURIComponent(t).replace(/\/{2,}/g,"/");return e.startsWith("/")||(e="/"+e),e.length>1&&e.endsWith("/")&&(e=e.slice(0,-1)),e||"/"}catch{return"/"}}static isBase(t,e){return"/"===t||t===e||e.startsWith(t+"/")}static*subpaths(t){if("/"===(t=t.trim()))return void(yield t);const e=t.startsWith("/")?"/":"",r=t.split("/");let n;for(let t of r)n=n?n+"/"+t:t,yield e+n}static route(t,e,r,n){const o=e.toUpperCase();if(t&&"function"==typeof t[o.toLowerCase()])t[o.toLowerCase()](r,async(t,e,r)=>{try{await n(t,e)}catch(t){r(t)}});else if(t&&"function"==typeof t.route)t.route({method:o,url:r,handler:n});else if(t&&"function"==typeof t.use&&Array.isArray(t.middleware))t.use(async(t,e)=>{if(t.method.toUpperCase()===o&&t.path===r)try{await n(t.req,t.res),t.respond=!1}catch(e){t.status=500,t.body={error:e.message}}else await e()});else{if(!t||"function"!=typeof t.on)throw new Error("Unsupported application framework");t.on("request",async(t,e)=>{const s=new URL(t.url,`http://${t.headers.host}`).pathname;if(t.method.toUpperCase()===o&&s===r)try{await m.prepare(t,e),await n(t,e)}catch(t){e.statusCode=500,e.end(t.message)}})}}static get(t,e){e=b.keys(e);let r=t;for(const t of e){if(null==r||!(t in r))return;r=r[t]}return r}static set(t,e,r,n=!1){if(!(e=b.keys(e)).length)throw new Error("Invalid path: empty keys");let o=t,s=0;for(const t of e.slice(0,-1)){if(!(t in o)){if(!n)throw new Error(`nonexistent path: ${e.slice(0,s+1).join(".")}`);o[t]={}}o=o[t],s++}o[e[e.length-1]]=r}static delete(t,e){e=b.keys(e),delete b.get(t,e.slice(0,-1))[e[e.length-1]]}static keys(t){return"string"==typeof t?t.split(".").filter(Boolean):[...t]}static isAncestor(t,e){const r=b.keys(t),n=b.keys(e);if(r.length>n.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==n[t])return!1;return!0}}class v extends s{static metaCtx="_hMeta";static as(t=t=>t,e=v.prototype){const r=s.as(t);return Object.setPrototypeOf(r,e),r}checking(t,e=async t=>!!t,r){return this.if(async n=>{if(!await e(v.ctx(n,t)))throw r;return n})}check(t,e=async t=>!!t,r){return this.sthen(async n=>{if(!await e(v.ctx(n,t)))throw r;return n})}setting(t,e,r=!0,n){return this.if(o=>v.doSet(o,t,e,r,n))}set(t,e,r=!0,n){return this.sthen(o=>v.doSet(o,t,e,r,n))}static async doSet(t,e,r,n=!0,o){try{const o=v.currentCtx(t),s="function"==typeof r?await r(o):await r;if(void 0===s)throw new Error("undefined result");return b.set(o,e,s,n),t}catch(t){throw o.clone?.(t)||o||t}}with(t,e=!0,r){return this.sthen(async n=>{let o=await b.get(n,v.metaCtx);o||(o=[],b.set(n,v.metaCtx,o));const s=o[o.length-1]||n;let i=b.get(s,t);if(void 0===i){if(!e)throw r;i={},b.set(s,t,i,!0)}return o.push(i),n})}without(t=1){return this.sthen(async e=>{let r=await b.get(e,v.metaCtx);if(Array.isArray(r)&&r.length>0){const n=Math.min(r.length,t);r.splice(r.length-n,n),r.length||b.delete(e,v.metaCtx)}return e})}static currentCtx(t){const e=b.get(t,v.metaCtx);return e?.at(-1)??t}static ctx(t,e){const r=v.currentCtx(t);return b.get(r,e)}}class g extends Error{constructor(t,e,r){super(t),this.name=this.constructor.name,this.path=e,r&&(this.cause=r)}clone(t){throw new Error("abstract method: subclasses must implement clone(cause)")}}class S extends g{constructor(t,e,r,n){super(e,r,n),this.statusCode=t}clone(t){return new S(this.statusCode,this.message,this.path,t)}}class k extends v{static as(t=t=>t){const e=v.as(t);return Object.setPrototypeOf(e,k.prototype),e}preparingBody(t=new S(422,"invalid or malformed JSON body")){return this.checking("req",async t=>await m.prepareBody(t),t)}prepareBody(t=new S(422,"invalid or malformed JSON body")){return this.check("req",async t=>await m.prepareBody(t),t)}preparingURL(t=new S(400,"invalid or malformed request URL")){return this.checking("req",m.prepareURL,t)}prepareURL(t=new S(400,"invalid or malformed request URL")){return this.check("req",m.prepareURL,t)}preparingQuery(){return this.checking("req",t=>m.prepareQuery(t))}prepareQuery(){return this.check("req",t=>m.prepareQuery(t))}preparingCookies(){return this.checking("req",t=>m.prepareCookies(t))}prepareCookies(){return this.check("req",t=>m.prepareCookies(t))}preparingToken(t=new S(401,"missing authentication token")){return this.checking("req",t=>m.prepareToken(t),t)}prepareToken(t=new S(401,"missing authentication token")){return this.check("req",t=>m.prepareToken(t),t)}checkingMethod(t,e=new S(405,"Invalid HTTP method")){return this.checking("req.method",e=>"string"==typeof e&&e===t,e)}checkMethod(t,e=new S(405,"Invalid HTTP method")){return this.check("req.method",e=>"string"==typeof e&&e===t,e)}checkingAccept(t,e=new S(406,"Not Acceptable")){return this.checking("req.headers.accept",e=>"string"==typeof e&&e.includes(t),e)}checkAccept(t,e=new S(406,"Not Acceptable")){return this.check("req.headers.accept",e=>"string"==typeof e&&e.includes(t),e)}checkingContentType(t,e=new S(400,"Invalid Content-Type")){return this.checking("req.headers.content-type",e=>"string"==typeof e&&e.includes(t),e)}checkContentType(t,e=new S(400,"Invalid Content-Type")){return this.check("req.headers.content-type",e=>"string"==typeof e&&e.includes(t),e)}}class A extends g{constructor(t,e,r=!1,n){super(t,e,n),this.isQuery=r}clone(t){return new A(this.message,this.path,this.isQuery,t)}}class I extends v{static as(t=t=>t){const e=v.as(t);return Object.setPrototypeOf(e,I.prototype),e}with(t,e=!1,r=!0,n=new A("Node not found for selector",t,e)){return e?this.sthen(e=>{const r=I.currentCtx(e,this.metaCtx);if(!r||"function"!=typeof r.querySelector)throw n.clone?.(new A("DomHandler.with: current context is not a DOM node, cannot querySelector",t,!0))||n;const o=r.querySelector(t);if(!o){const e=new A(`DomHandler.with: querySelector failed for selector "${t}"`,t,!0);throw n.clone?.(e)||n||e}const s=e[this.metaCtx]||[];return s.push(o),e[v.metaCtx]=s,e}):super.with(t,r,n)}settingAttr(t,e,r=new A("Not a DOM element")){return this.if(n=>I.doSetAttr(n,t,e,r))}setAttr(t,e,r=new A("Not a DOM element")){return this.sthen(n=>I.doSetAttr(n,t,e,r))}static doSetAttr(t,e,r,n=new A("Not a DOM element")){const o=v.currentCtx(t);if(!o||"function"!=typeof o.setAttribute){const t=new A("doSetAttr: current context cannot setAttribute");throw n.clone?.(t)||n||t}return o.setAttribute(e,r),t}checkingAttr(t,e=t=>!!t,r=new A("Invalid or missing attribute")){return this.if(n=>I.doCheckAttr(n,t,e,r))}checkAttr(t,e=t=>!!t,r=new A("Invalid or missing attribute")){return this.sthen(n=>I.doCheckAttr(n,t,e,r))}static doCheckAttr(t,e,r,n=new A("Invalid or missing attribute")){const o=v.currentCtx(t);if(!o||"function"!=typeof o.getAttribute){const t=new A("doCheckAttr: current context cannot getAttribute");throw n.clone?.(t)||n||t}if(!r(o.getAttribute(e))){const t=new A(`doCheckAttr: attribute "${e}" failed validation`,e,!0);throw n.clone?.(t)||n||t}return t}}class C{static on(t,e,r,n,o,s){if(s||(s=t),"string"==typeof s&&(s=t[s]||(t[s]={})),o&&s[o]&&this.off(t,e,o,n,s),n?.once&&"function"==typeof t.once)t.once(e,r);else if("function"==typeof t.addEventListener)t.addEventListener(e,r,n);else if("function"==typeof t.addListener)t.addListener(e,r);else{if("function"!=typeof t.on)throw new Error("on-failed",{event:e,fn:r,opts:n,name:o,registry:s},t);t.on(e,r)}o&&(s[o]=r)}static off(t,e,r,n,o){let s=r;if("string"==typeof r){if("string"==typeof o&&(o=t[o]),!o)return;s=o[r],delete o[r]}if(s)if("function"==typeof t.removeEventListener)t.removeEventListener(e,s,n);else if("function"==typeof t.removeListener)t.removeListener(e,s);else{if("function"!=typeof t.off)throw new Notification("off-failed",{event:e,nameOrFn:r,opts:n,registry:o},t);t.off(e,s)}}static emit(t,e,...r){if("string"!=typeof e&&(r=[e],e=e?.type||"object"),"function"==typeof t.emit)return t.emit(e,...r);if("function"==typeof t.dispatchEvent)return t.dispatchEvent(C.toCustomEvent(r[0]));throw new Error("emit-failed: Target cannot emit events")}static toCustomEvent(t,e="object"){return t instanceof CustomEvent?t:"string"==typeof t?new CustomEvent(t,{detail:{}}):new CustomEvent(t?.type||e,{obj:t})}}return e})());